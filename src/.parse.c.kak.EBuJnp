#include "parse.h"
#include <stdlib.h>
#include "asm.h"

#define PRIORITY_MULTIPLY 2
#define PRIORITY_ADD 1
#define PRIORITY_SUB 0

void parse_program(const Token* tokens) {
	printf("\nParsing and emitting nasm...\n");

	FILE* nasm;
	nasm = fopen(ASM_PATH, "w");

	fprintf(nasm, "global _start\n_start:\n");

	uint32_t token_index = 0;
	while(tokens[token_index].type != TOKEN_PROGRAM_END) {
		parse_statement(tokens, &token_index, nasm);
	}

	fclose(nasm);

	printf("Parsing complete.\n");
}

void parse_statement(const Token* tokens, uint32_t* token_index, FILE* nasm) {
	*token_index += 1;
	switch(tokens[*token_index - 1].type) {
	case TOKEN_EXIT:
		parse_exit(tokens, token_index, nasm);
		break;
	case TOKEN_ASSIGN:
		// TODO: parse assign statement
		printf("Error: Expected exit statement, got assign.\n");
		exit(1);
		parse_assign(tokens, token_index, nasm);
		break;
	case TOKEN_OUT:
		// TODO: parse out statement
		printf("Error: Expected exit statement, got out token.\n");
		exit(1);
		parse_out(tokens, token_index, nasm);
		break;
	default:
		printf("Error: Expected exit statement, got nothing.\n");
		exit(1);
		break;
	}
}

void parse_exit(const Token* tokens, uint32_t* token_index, FILE* nasm) {
	Expression expr = parse_expression(tokens, token_index, nasm, 0);
	if(expr.type == EXPR_BYTE) {
		if(tokens[*token_index].type != TOKEN_STATEMENT_END) {
			printf("Error: Expected statement end after exit command.\n");
		}
		*token_index += 1;
		fprintf(nasm, "mov rdi, %u\n", expr.value.byte);
		fprintf(nasm, "mov rax, 60\n");
		fprintf(nasm, "syscall\n");
	} else {
		printf("Error: Expected byte expression when parsing exit.\n");
		exit(1);
	}
}

void parse_assign(const Token* tokens, uint32_t* token_index, FILE* nasm) {
	// TODO: implement parse_assign
}

void parse_out(const Token* tokens, uint32_t* token_index, FILE* nasm) {
	// TODO: implement parse_out
}

Expression parse_expression(const Token* tokens, uint32_t* token_index, FILE* nasm, uint8_t parse_priority) {
	if(tokens[*token_index].type == TOKEN_BYTE_LITERAL) {
		*token_index += 1;

		Expression left = (Expression){EXPR_BYTE, tokens[*token_index - 1].value.byte};
		if(tokens[*token_index].type == TOKEN_ADD) {
			*token_index += 1;
			Expression right = parse_expression(tokens, token_index, nasm, PRIORITY_ADD);

			if(right.type != EXPR_BYTE) {
				printf("Error: Expected right hand expression to resolve to a byte literal.\n");
				exit(1);
			}

			Expression res = (Expression){EXPR_BYTE, left.value.byte + right.value.byte};
			return res;
		} else {
			return left;
		}
		
	} else {
		printf("Error: Expected byte literal when parsing expression.\n");
		exit(1);
	}
	
}

/*
parsing expression 3 * 4 + 5

priorities
+: 5
*: 10

parse(-inf)
	see 3
	see *, which means recurse
	priority 10 is higher than -inf, so we DO recurse
	parse(10) // pass the priority of outer recursion scope
		see 4
		see +, which means recurse
		priority 5 is lower than 10, so we do NOT recurse
		intead, we return 4
	now we are in outer scope, with left side of tree = 3 * 4
	see +, which means recurse
	priority 5 is higher than -inf, so we DO recurse
	parse(5)

OR

parse_expression(0)
	if(!byte) 
		error
	Expr left = {BYTE, token.value}
	switch(next_token)
		case 
*/
